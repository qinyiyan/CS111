# Fill in your name, student ID, and email address in this file.

# If you are working in a team, remove the # signs from the three lines for
# partner 2 below and fill them in as well. Please submit the lab to CourseWeb
# only once (from only one partner). This file will be automatically parsed in
# order to give both team members credit for the lab.

# If you have any other information you'd like us to know, please add it at
# the end of the file.

# Partner 1
Name: Qinyi Yan	
Student ID: 704406413
Email: qinyiyan1106@gmail.com

# Partner 2
#Name: Xiaoxuan Wang
#Student ID: 804406399
#Email: wangxiaoxuan7875@gmail.com


# Add any other information you'd like us to have below this line.
The 17 given testcases are passed. We added two more testcases in order to test deadlock. The deadlock checking function works well to detect function. We check deadlock everytime acquiring a read/write lock, and if there is no deadlock, add the process to a queue containing all the processes that is waiting for the CS or having the lock of the CS. By checking the order of queues between different critical sections, we can detect a deadlock if the order of queue of two CSs are in confliction, meaning one has P1P2P3 and the other has P3P2P1. 

# Answers to the questions:
Question 1:What assumptions were made that have L._nwaiting++in a CS but not return L._nwaiting?
Answer:


Question 2:Suppose P3did release C (at step 6) before locking A. Could deadlock ever occur?
Answer: No, the deadlock won't occur. If P3 releases lock C before locking A, P2 will get the lock C and have a chance to run and finish at some point. When P2 finishes, it will release lock B and lock C, then P1 can get the lock B and run to finish. After P1 finish and release lock A, P3 gets the chance to access to drive D and run. The deadlock will not occur.