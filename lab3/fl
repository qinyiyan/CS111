534c534,535
< 	for (entry_off = 0; entry_off < dir_oi->oi_size; entry_off += OSPFS_DIRENTRY_SIZE) {
---
> 	for (entry_off = 0; entry_off < dir_oi->oi_size;
> 	     entry_off += OSPFS_DIRENTRY_SIZE) {
547,554d547
< 	if (check_writes_to_crash())
< 		return 0;
< 
< 	oi->oi_nlink--;
< 
< 	if (check_writes_to_crash())
< 		return 0;
< 
555a549,552
> 	oi->oi_nlink--;
> 	//considering symbolic link
> 	if (oi->oi_ftype != OSPFS_FTYPE_SYMLINK &&oi->oi_nlink == 0)
> 		return (change_size(oi,0));
558a556,557
> 
> 
1433,1441c1432,1435
< 	ospfs_symlink_inode_t* link;
< 
< 	// check if name too long
< 	if (dentry->d_name.len > OSPFS_MAXNAMELEN ||
< 		strlen(symname) > OSPFS_MAXSYMLINKLEN)
<         return -ENAMETOOLONG;
< 	// check if directory entry already exists
< 	if (find_direntry(ospfs_inode(dir->i_ino),
< 		dentry->d_name.name, dentry->d_name.len))
---
> 	/* EXERCISE: Your code here. */
> 	if (dentry->d_name.len > OSPFS_MAXNAMELEN)
> 		return -ENAMETOOLONG;
> 	if (find_direntry(dir_oi, dentry->d_name.name, dentry->d_name.len))
1443,1456c1437,1469
< 
< 	// create new symlinked file
< 	entry_ino = ospfs_create(dir, dentry, dir_oi->oi_mode, NULL);
< 	if (entry_ino < 0)
< 		return entry_ino;
< 	entry_ino = find_direntry(ospfs_inode(dir->i_ino),
< 		dentry->d_name.name, dentry->d_name.len)->od_ino;
< 	link = (ospfs_symlink_inode_t*) ospfs_inode(entry_ino);
< 
< 	// copy file information
< 	link->oi_size = strlen(symname);
< 	link->oi_ftype = OSPFS_FTYPE_SYMLINK;
< 	link->oi_nlink = 1;
< 	memcpy(link->oi_symlink, symname, strlen(symname));
---
> 	//create a new symlink inode
> 	ospfs_inode_t *free_inode = ospfs_block(ospfs_super->os_firstinob);
> 	uint32_t count = 1;
> 	while(count<ospfs_super->os_ninodes)
> 	{
> 		if (free_inode[count].oi_nlink == 0)
> 			break;
> 		count++;
> 	}
> 	//no free inode
> 	if (count == ospfs_super->os_ninodes)
> 	{
> 		count = 0;
> 		return -ENOSPC;
> 	}
> 	else 
> 		entry_ino = count;
> 	//create new inode and entry;
> 	ospfs_symlink_inode_t* symlink_oi = ospfs_inode(entry_ino);
> 	ospfs_direntry_t * sym_dentry = create_blank_direntry(dir_oi);
> 	if (IS_ERR(sym_dentry))
> 		return PTR_ERR(sym_dentry);
> 	//init symlink inode:
> 	if (strlen(symname)>OSPFS_MAXSYMLINKLEN)
> 		return -ENAMETOOLONG;
> 	symlink_oi->oi_size = strlen(symname);
> 	symlink_oi->oi_ftype = OSPFS_FTYPE_SYMLINK;
> 	symlink_oi->oi_nlink = 1;
> 	memcpy (symlink_oi->oi_symlink, symname, strlen(symname)); 
> 	symlink_oi->oi_symlink[strlen(symname)] = '\0';
> 	memcpy (sym_dentry->od_name, dentry->d_name.name, dentry->d_name.len);
> 	sym_dentry->od_name[dentry->d_name.len] = '\0';
> 	sym_dentry->od_ino = entry_ino;
1484c1497
< /*
---
> 
1510,1537d1522
< */
< static void *
< ospfs_follow_link(struct dentry *dentry, struct nameidata *nd)
< {
< 	ospfs_symlink_inode_t *oi = (ospfs_symlink_inode_t *) ospfs_inode(dentry->d_inode->i_ino);
< 	char temp[OSPFS_MAXNAMELEN + 1];
< 
< 	if (strchr(oi->oi_symlink, '?') != NULL && strchr(oi->oi_symlink, ':') != NULL) { // usual symlink
< 		if (current->uid == 0 && strncmp(oi->oi_symlink,"root?",5) == 0) {
< 			char *quest_ptr = strchr(oi->oi_symlink, '?') + 1;
< 			int length = strcspn(quest_ptr, ":");
< 
< 			strncpy(temp, quest_ptr, length);
< 			temp[length] = '\0';
< 		} else {
< 			char *colon_ptr = strchr(oi->oi_symlink, ':') + 1;
< 
< 			strcpy(temp, colon_ptr);
< 		}
< 
< 		nd_set_link(nd, temp);
< 	} else { // conditional symlink
< 		nd_set_link(nd, oi->oi_symlink);
< 	}
< 
< 	return (void *) 0;
< }
< 
